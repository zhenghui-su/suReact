## React 协调器工作流程详解

1. **准备阶段**：
   在准备阶段，我们初始化工作栈，并将根 Fiber 节点作为起点。
   初始时，将根节点放入工作栈中，表示我们需要处理根节点及其子节点。
2. **渲染根节点**：
   开始渲染根节点时，我们进入一个循环，即工作循环。
   工作循环持续进行直到工作栈为空。
   在每次循环中，我们从工作栈中取出一个节点，并开始处理它。
3. **执行工作单元**：
   对于每个工作单元，我们执行一系列操作来处理它：
   开始工作：根据节点类型执行相应的操作，如创建 DOM 节点、调用函数组件等。
   处理属性：将节点的属性应用到相应的 DOM 节点上。
   生成子节点：根据节点的类型和属性，生成子节点并将其添加到工作栈中。
4. **完成工作单元**：
   当一个工作单元的任务完成后，我们执行一系列清理操作，并移动到下一个工作单元。
   如果当前节点有兄弟节点，则将兄弟节点作为下一个工作单元。
   如果没有兄弟节点，则将父节点作为下一个工作单元，并向上遍历树结构，直到找到下一个有兄弟节点的节点为止。
5. **循环处理**：
   工作循环持续进行，直到工作栈中没有任何待处理的节点。
   在每次循环中，我们持续从工作栈中取出节点，并处理它们的工作单元，直到整个组件树的更新和渲染工作完成。

## 示例：计数器组件

考虑一个简单的计数器组件：

```jsx
function Counter() {
	const [count, setCount] = useState(0);

	return (
		<div>
			<h1>{count}</h1>
			<button onClick={() => setCount(count + 1)}>Increase</button>
		</div>
	);
}
```

当用户点击增加按钮时，计数器会增加一个数字。现在，让我们看看 React 协调器是如何处理这个组件的更新和渲染的：

1. **准备阶段：**
   - 初始化工作栈，并将 `Counter` 组件的根 Fiber 节点放入工作栈中。
2. **渲染根节点：**
   - 进入工作循环，开始处理 `Counter` 组件。
3. **执行工作单元：**
   - 开始工作：创建计数器组件的 DOM 结构。
   - 处理属性：将初始状态 `count` 渲染到 DOM 中。
   - 生成子节点：为增加按钮添加事件监听器，并将其添加到工作栈中。
4. **完成工作单元：**
   - 完成计数器组件的更新，并将下一个工作单元设置为增加按钮的事件监听器。
   - 工作栈中没有其他待处理的节点，因此循环结束。
5. **循环处理：**
   - 由于目前没有其他待处理的节点，工作循环结束，计数器组件的更新和渲染过程完成。

## 循环处理：DFS

### 循环处理的方法：

1. **工作栈：**
   - 在 React 协调器中，使用一个工作栈来存储待处理的节点。
   - 初始时，将根节点放入工作栈中。
2. **工作循环：**
   - 在循环中，不断从工作栈中取出节点，并处理其工作单元，直到工作栈为空。
   - 每次循环都会处理一个节点，并可能生成新的工作单元，将其添加到工作栈中。
3. **处理工作单元：**
   - 对于每个工作单元，执行一系列操作来处理节点。
   - 这些操作包括开始工作、处理属性、生成子节点等。
4. **完成工作单元：**
   - 当一个工作单元的任务完成后，执行一系列清理操作，并移动到下一个工作单元。
   - 如果当前节点有兄弟节点，则将兄弟节点作为下一个工作单元。
   - 如果没有兄弟节点，则将父节点作为下一个工作单元，并向上遍历树结构，直到找到下一个有兄弟节点的节点为止。
5. **循环终止：**
   - 当工作栈中没有任何待处理的节点时，循环结束，整个组件树的更新和渲染过程完成。

### 使用 DFS 算法实现：

- 在工作循环中，我们从工作栈中取出节点，这实际上是一个深度优先搜索的过程。
- 深度优先搜索会从根节点开始，沿着每个分支尽可能深地搜索，直到遍历完整个树或者达到终止条件。
- 在 React 协调器中，我们通过深度优先搜索来遍历组件树，并在遍历的过程中处理每个节点的工作单元。

### 举例说明：

假设我们有一个简单的组件树：

```css
       A
   ____|____
  |    |    |
  B    C    D
 /|\       /|\
E F G     H I J
```

在这个组件树中，根节点 A 有三个子节点 B、C、D，其中 B 和 D 各有三个子节点 E、F、G 和 H、I、J。

我们来看看在循环处理过程中，如何通过深度优先搜索来处理这个组件树：

1. 开始时，将根节点 A 放入工作栈中。
2. 第一次循环处理节点 A，执行其工作单元并生成子节点 B、C、D。
3. 将子节点依次添加到工作栈中。
4. 继续循环处理节点 B，将其子节点 E、F、G 添加到工作栈中。
5. 循环处理节点 E，F，G。
6. 当节点 E，F，G 的工作单元完成后，将处理节点 B 的工作单元完成，并移动到下一个兄弟节点 C。
7. 循环处理节点 C，处理节点 C 的工作单元。
8. 当处理节点 C 的工作单元完成后，移动到下一个兄弟节点 D。
9. 继续循环处理节点 D，将其子节点 H、I、J 添加到工作栈中。
10. 循环处理节点 H，I，J。
11. 当节点 H，I，J 的工作单元完成后，将处理节点 D 的工作单元完成。
12. 工作栈为空，循环结束。
