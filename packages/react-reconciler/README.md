## React 协调器工作流程详解

1. **准备阶段**：
   在准备阶段，我们初始化工作栈，并将根 Fiber 节点作为起点。
   初始时，将根节点放入工作栈中，表示我们需要处理根节点及其子节点。
2. **渲染根节点**：
   开始渲染根节点时，我们进入一个循环，即工作循环。
   工作循环持续进行直到工作栈为空。
   在每次循环中，我们从工作栈中取出一个节点，并开始处理它。
3. **执行工作单元**：
   对于每个工作单元，我们执行一系列操作来处理它：
   开始工作：根据节点类型执行相应的操作，如创建 DOM 节点、调用函数组件等。
   处理属性：将节点的属性应用到相应的 DOM 节点上。
   生成子节点：根据节点的类型和属性，生成子节点并将其添加到工作栈中。
4. **完成工作单元**：
   当一个工作单元的任务完成后，我们执行一系列清理操作，并移动到下一个工作单元。
   如果当前节点有兄弟节点，则将兄弟节点作为下一个工作单元。
   如果没有兄弟节点，则将父节点作为下一个工作单元，并向上遍历树结构，直到找到下一个有兄弟节点的节点为止。
5. **循环处理**：
   工作循环持续进行，直到工作栈中没有任何待处理的节点。
   在每次循环中，我们持续从工作栈中取出节点，并处理它们的工作单元，直到整个组件树的更新和渲染工作完成。

## 示例：计数器组件

考虑一个简单的计数器组件：

```jsx
function Counter() {
	const [count, setCount] = useState(0);

	return (
		<div>
			<h1>{count}</h1>
			<button onClick={() => setCount(count + 1)}>Increase</button>
		</div>
	);
}
```

当用户点击增加按钮时，计数器会增加一个数字。现在，让我们看看 React 协调器是如何处理这个组件的更新和渲染的：

1. **准备阶段：**
   - 初始化工作栈，并将 `Counter` 组件的根 Fiber 节点放入工作栈中。
2. **渲染根节点：**
   - 进入工作循环，开始处理 `Counter` 组件。
3. **执行工作单元：**
   - 开始工作：创建计数器组件的 DOM 结构。
   - 处理属性：将初始状态 `count` 渲染到 DOM 中。
   - 生成子节点：为增加按钮添加事件监听器，并将其添加到工作栈中。
4. **完成工作单元：**
   - 完成计数器组件的更新，并将下一个工作单元设置为增加按钮的事件监听器。
   - 工作栈中没有其他待处理的节点，因此循环结束。
5. **循环处理：**
   - 由于目前没有其他待处理的节点，工作循环结束，计数器组件的更新和渲染过程完成。

## 循环处理：DFS

### 循环处理的方法：

1. **工作栈：**
   - 在 React 协调器中，使用一个工作栈来存储待处理的节点。
   - 初始时，将根节点放入工作栈中。
2. **工作循环：**
   - 在循环中，不断从工作栈中取出节点，并处理其工作单元，直到工作栈为空。
   - 每次循环都会处理一个节点，并可能生成新的工作单元，将其添加到工作栈中。
3. **处理工作单元：**
   - 对于每个工作单元，执行一系列操作来处理节点。
   - 这些操作包括开始工作、处理属性、生成子节点等。
4. **完成工作单元：**
   - 当一个工作单元的任务完成后，执行一系列清理操作，并移动到下一个工作单元。
   - 如果当前节点有兄弟节点，则将兄弟节点作为下一个工作单元。
   - 如果没有兄弟节点，则将父节点作为下一个工作单元，并向上遍历树结构，直到找到下一个有兄弟节点的节点为止。
5. **循环终止：**
   - 当工作栈中没有任何待处理的节点时，循环结束，整个组件树的更新和渲染过程完成。

### 使用 DFS 算法实现：

- 在工作循环中，我们从工作栈中取出节点，这实际上是一个深度优先搜索的过程。
- 深度优先搜索会从根节点开始，沿着每个分支尽可能深地搜索，直到遍历完整个树或者达到终止条件。
- 在 React 协调器中，我们通过深度优先搜索来遍历组件树，并在遍历的过程中处理每个节点的工作单元。

### 举例说明：

假设我们有一个简单的组件树：

```css
       A
   ____|____
  |    |    |
  B    C    D
 /|\       /|\
E F G     H I J
```

在这个组件树中，根节点 A 有三个子节点 B、C、D，其中 B 和 D 各有三个子节点 E、F、G 和 H、I、J。

我们来看看在循环处理过程中，如何通过深度优先搜索来处理这个组件树：

1. 开始时，将根节点 A 放入工作栈中。
2. 第一次循环处理节点 A，执行其工作单元并生成子节点 B、C、D。
3. 将子节点依次添加到工作栈中。
4. 继续循环处理节点 B，将其子节点 E、F、G 添加到工作栈中。
5. 循环处理节点 E，F，G。
6. 当节点 E，F，G 的工作单元完成后，将处理节点 B 的工作单元完成，并移动到下一个兄弟节点 C。
7. 循环处理节点 C，处理节点 C 的工作单元。
8. 当处理节点 C 的工作单元完成后，移动到下一个兄弟节点 D。
9. 继续循环处理节点 D，将其子节点 H、I、J 添加到工作栈中。
10. 循环处理节点 H，I，J。
11. 当节点 H，I，J 的工作单元完成后，将处理节点 D 的工作单元完成。
12. 工作栈为空，循环结束。

## ReactDOM.createRoot().render() 模拟流程

如下图

![image-20240404233832703](https://chen-1320883525.cos.ap-chengdu.myqcloud.com/img/image-20240404233832703.png)

### 流程

1. **创建根容器：**
   - 使用 `createContainer` 函数创建根容器，并与根节点相关联。
   - `createContainer` 函数内部创建了一个 `FiberRootNode` 对象，并初始化了根 Fiber 节点，并将其与容器关联起来。
2. **触发更新：**
   - 当执行 `ReactDOM.createRoot().render()` 时，实际上调用了 `updateContainer` 函数。
   - `updateContainer` 函数会创建更新对象，并将其加入到根节点的更新队列中。
   - 然后，调用 `scheduleUpdateOnFiber` 函数来触发更新调度。
3. **标记更新并开始渲染：**
   - `scheduleUpdateOnFiber` 函数会标记更新，并调用 `renderRoot` 函数来开始渲染根节点。
   - `renderRoot` 函数准备工作栈，并进入循环处理工作单元的过程。
4. **循环处理工作单元：**
   - 在循环中，调用 `performUnitOfWork` 函数执行当前工作单元。
   - `performUnitOfWork` 函数会开始处理当前工作单元，并获取下一个要处理的工作单元。
   - 如果没有下一个工作单元，则调用 `completeUnitOfWork` 函数完成当前工作单元。
   - 如果有下一个工作单元，则将全局变量 `workInProgress` 更新为下一个工作单元，并继续循环处理。

### 代码关联

- `createContainer`、`updateContainer` 函数调用了 `FiberRootNode` 的相关方法和属性，与 `fiber.ts` 中的定义关联。
- `scheduleUpdateOnFiber`、`renderRoot`、`workLoop`、`performUnitOfWork`、`completeUnitOfWork` 等函数实现了更新调度和渲染的逻辑，与 `workLoop.ts` 中的代码关联。
- `markUpdateFromFiberToRoot` 函数用于标记更新的起点，与 `workLoop.ts` 中的代码关联。
- 这些函数都依赖于 `FiberNode`、`FiberRootNode` 类的定义，与 `fiber.ts` 中的代码关联。
- `createContainer` 和 `updateContainer` 函数中使用了更新队列相关的方法和属性，与 `updateQueue.ts` 中的代码关联。

## Mount 阶段 beginWork 的流程和书写

Mount阶段的beginWork函数是React Fiber Reconciler的一部分，负责在构建Fiber树时执行初始化工作，并开始处理工作单元。以下是该阶段的流程解析：

1. **参数接收：** beginWork函数接收一个参数 `wip`，代表当前正在进行工作的Fiber节点。
2. **判断Fiber节点类型：** 使用`switch`语句检查当前节点的类型，根据不同的类型执行相应的操作。
3. **更新HostRoot节点：** 如果当前节点是HostRoot类型，则执行以下步骤：
   - 获取基础状态和更新队列。
   - 处理更新队列，获取memoizedState。
   - 更新memoizedState。
   - 获取下一个子节点。
   - 调用`reconcilerChildren`函数协调子节点。
4. **更新HostComponent节点：** 如果当前节点是HostComponent类型，则执行以下步骤：
   - 获取下一个props。
   - 获取下一个子节点。
   - 调用`reconcilerChildren`函数协调子节点。
5. **协调子节点：** reconcilerChildren函数接收当前正在进行工作的Fiber节点 `wip` 和下一个子节点 `children` 作为参数，根据当前Fiber节点是否有alternate节点执行不同的逻辑：
   - 如果有alternate节点，表示是update流程，调用`reconcileChildFibers`函数协调子节点的更新。
   - 如果没有alternate节点，表示是mount流程，调用`mountChildFibers`函数协调子节点的挂载。
